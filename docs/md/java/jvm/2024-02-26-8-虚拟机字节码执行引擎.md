---
title: 第八章、虚拟机字节码执行引擎
---
# 第八章、虚拟机字节码执行引擎

## 8.1 概述

执行引擎是Java虚拟机核心的组成部分之一。物理机的执行引擎直接建立在处理器、缓存、指令集和操作系统层面上，而虚拟机的执行引擎则是由软件自行实现的，因此可以不受物理条件制约地定制指令集与执行引擎地结构体系，能够执行那些不被硬件直接支持地指令集格式

## 8.2 运行时栈帧结构

栈帧是支持虚拟机进行方法调用和方法执行背后的数据结构。栈帧存储了方法的局部变量表、操作数栈、动态连接和方法返回地址等信息，每一个方法从调用开始至执行结束的过程，都对应着一个栈帧在虚拟机栈里面从入栈到出栈的过程

### 8.2.1 局部变量表

局部变量表是一组变量值的存储空间，用于存放方法参数和方法内部定义的布局变量。在方法的Code属性的max_locals数据项中确定了该方法所需分配的局部变量表的最大容量。局部变量表的容量以变量槽为最小单位

一个变量槽可以存放一个32位以内的数据类型：boolean、byte、char、short、 int、float、reference(对象实例的引用)和returnAddress，而64位的long、double会以高位对齐的方式为其分配两个连续的变量槽空间。Java虚拟机通过索引定位的方式使用局部变量表，索引值的范围是从0开始至局部变量表最大的变量槽数量。访问32位数据类型时索引N就代表第N个；访问64位时，会同时使用第N和N+1两个变量槽

当一个方法被调用时，Java虚拟机会使用局部变量表来完成参数值到参数变量列表的传递过程，即实参到形参的传递。如果执行的是实例方法，局部变量表第0位索引的变量槽默认是用于传递方法所属对象实例的引用(即this)，其余参数按参数表顺序排列，其后跟据方法内部定义的变量顺序和作用域分配其他的变量槽

### 8.2.2 操作数栈

操作数栈的最大深度也在编译时被写入Code属性的max_stacks数据项之中。随着方法的执行，就有各种字节码指令往操作数栈中写入和提取内容，也就是出栈和入栈操作。

### 8.2.3 动态连接

每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用，持有这个引用是为了支持方法调用过程中的动态连接。

### 8.2.4 方法返回地址

当一个方法开始执行后，只有两种方式退出这个方法：

- 执行引擎遇到任意一个方法返回的字节码指令，称为正常调用完成
- 执行过程中遇到异常，并没有在方法体内得到妥善处理。不论是Java虚拟机内部的异常，还是代码使用athrow字节码指令产生的异常，只要本方法的异常表中没有搜索到匹配的异常处理器，就会导致方法退出，称为异常调用完成

正常退出时，主调方法的PC计数器的值就可以作为返回地址；而异常退出时，返回地址要通过异常处理器表来确定

方法退出的过程实际上等同于当前栈帧出栈，退出时可能执行的操作有：恢复上层方法的局部变量表和操作数栈，把返回值压入调用者栈帧的操作数栈中，调整PC计数器的值以指向方法调用指令后面的一条指令等

### 8.2.5 附加信息

《Java虚拟机规范》允许虚拟机实现增加一些规范里没有描述的信息到栈帧中，例如与调试、性能收集相关的信息，这部分信息完全取决于具体的虚拟机实现。在讨论概念时，一般会把动态连接、方法返回地址与其他附加信息全部归为一类，称为栈帧信息

## 8.3 方法调用

### 8.3.1 解析

类加载的解析阶段，会将其中的一部分符号引用转化为直接引用，这种解析能够成立的前提是：方法在程序真正运行之前就有一个可确定的调用版本，并且这个方法的调用版本在运行期是不可改变的。即调用目标在程序代码写好、编译器进行编译那一刻就已经确定下来，这类方法的调用称为解析

符合这个要求的方法，主要有静态方法和私有方法两大类

调用不同类型的方法，字节码指令集里设计了不同的指令：

- invokestatic：用于调用静态方法
- invokespecial：用于调用实例构造器`<init>()`方法、私有方法和父类中的方法
- invokevirtual：用于调用所有的虚方法
- invokeinterface：用于调用接口方法，会在运行时再确定一个实现该接口的对象
- invokedynamic：先在运行时动态解析出调用点限定符所引用的方法，然后再执行该方法。前面4条调用指令，分派逻辑都固化在Java虚拟机内部，而invokedynamic指令的分派逻辑是由用户设定的引导方法决定的

只要能被invokestatic和invokespecial指令调用的方法，都可以在解析阶段中确定唯一的调用版本，Java语言里符合这个条件的方法共有静态方法、私有方法、实例构造器、父类方法4种，再加上被final修饰的方法，这5种方法调用会在类加载的时候就可以把符号引用解析为该方法的直接引用，这些方法统称为非虚方法

### 8.3.2 分派

因为Java具备面向对象的3个基本特征：继承、封装和多态。而分派调用过程将会揭示多态性特征的一些最基本的体现

#### 8.3.2.1 静态分派

<font color="red">静态分派与方法的重载是相关的</font>，我们设置两个类，一个类是父类Human，一个是子类Man，那么当我们用以下的方式初始化一个对象时，Human表示该变量的静态类型，Man表示该变量的实际类型：

```java
Human man = new Man();
```

静态类型和实际类型在程序中都可能发生变化，区别是静态类型的变化仅仅在使用时发生，且变量本身的静态类型不会被改变，且静态类型在编译器是可知的；而实际类型变化的结果在运行期才能够确定。

<font color="red">在方法重载时，使用哪个重载版本取决于传入参数的数量和数据类型，编译器在重载时是通过参数的静态类型而不是实际类型来决定重载方法的</font>，静态类型在编译期是可知的。所有依赖于静态类型来决定方法执行版本的分派动作，都称为静态分派。

方法重载时编译器会不断地寻找合适的方法，如果静态类型所对应的方法没有找到，就会从该静态类型能够转换的类型开始寻找，如果这种方法还没有找到，就会进行自动装箱找它的封装类型，如果还没有找到，就会寻找该装箱类所实现的接口类型或从下往上地寻找父类

#### 8.3.2.2 动态分派

<font color="red">动态分派与重写是相关的</font>，当两个子类都重写了父类的某一个方法时，编译器如何分辨这两个方法呢？从Class字节码的指令中可以看出，两个子类对象首先被压入栈顶，他们是将要执行重写方法的所有者，称为接受者。然后执行invokespecial指令，参数是父类方法的符号引用，并不是子类方法的符号引用，也就是说是invokespecial指令搞的鬼

1. invokespecial指令首先找到操作数栈顶的第一个元素所指向的对象的实际类型
2. 如果在该类型中找到与指令参数中的父类符号引用中的描述符和简单名称都相符的方法，则进行访问权限校验，如果通过则返回这个方法的直接引用，否则返回java.lang.IllegalAccessError异常
3. 如果没有找到该方法，则按照继承关系从下往上对该类型的各个父类进行搜索和验证
4. 如果最终还是没有找到合适的方法，则抛出java.lang.AbstractMethodError异常

这种在运行期根据实际类型确定方法执行版本的分派过程称为动态分派。动态分派是由虚方法调用指令invokespecial实现的，因此只对方法有效，对字段是无效的，因为字段无法使用这条指令，字段是不参与多态的。当子类声明了父类同名的字段时，子类的字段会覆盖父类的同名字段。

#### 8.3.2.3 单分派与多分派

方法的接受者和方法的参数统称为方法的宗量，根据宗量的数量，将分派分为单分派和多分派两种：

- 单分派是根据一个宗量对目标方法进行选择
- 多分派是根据多于一个宗量对目标方法进行选择

Java语言的静态分派是根据静态类型和方法参数来选择的，属于多分派类型；动态分派是根据接受者的实际类型选择的，因此属于单分派类型

#### 8.3.2.4  虚拟机动态分派的实现

动态分派是执行非常频繁的动作，而且动态分派的方法版本选择过程需要运行时在接收者类型的方法元数据中搜索合适的目标方法。因此，Java虚拟机实现基于执行性能的考虑，真正运行时一般不会如此频繁地去反复搜索类型元数据。

而一种基础而且常见地优化手段是为类型在方法区中建立一个虚方法表，使用虚方法表索引来代替元数据查找以提高性能

虚方法表中存放着各个方法的实际入口，如果某个方法在子类中没有被重写，那子类的虚方法表中的地址入口和父类相同方法的地址入口是一致的，都指向父类的实现入口，如果子类中重写了这个方法，子类虚方法表中的地址也会被替换成指向子类实现版本的入口地址

## 8.4 动态类型语言支持

## 8.5 基于栈的字节码解释执行引擎

### 8.5.1 解释执行

Java中，javac编译器完成了程序代码经过词法分析、语法分析到抽象语法树，再遍历语法树生成线性的字节码指令流的过程。因为这一部分动作是在Java虚拟机之外进行的，而解释器在虚拟机的内部，所以Java程序的编译就是半独立的实现

### 8.5.2 基于栈的指令集与基于寄存器的指令集

javac编译器输出的字节码指令流，基本上是一种基于栈的指令集架构；与之相对的另一套常用的指令集架构是基于寄存器的指令集，即物理硬件直接支持的指令集

```text
两者区别，分别使用两种指令集计算1+1
基于栈的指令集：
iconst_1
iconst_1
iadd
istore_0
把两个常量1压入栈中，idd把栈顶两个值出栈相加，然后把结果放回栈顶，最后istore_0把栈顶的值放到局部遍历表的第0个变量槽中
基于寄存器的指令集：
mov eax, 1
add eax, 1
mov指令把EAX寄存器的值设为1，然后add指令再把这个值加1
```

基于栈的指令集优点在于可移植，此外还有代码相对更加紧凑、编译器实现更加简单等

而缺点在于理论上执行速度相对会慢一些(局限在解析执行的状态下，如果经过即时编译器输出成物理机上的汇编指令流，那就与虚拟机采用哪种指令集架构没有关系了)。因为出栈入栈本身就会产生大量的指令，且伴随着内存访问，即便采取栈顶缓存的优化，但终归只能是优化措施。而就是指令数量和内存访问的原因，导致了栈架构指令集的执行速度会相对慢一些

### 8.5.3 基于栈的解释器执行过程

```java
public int calc() {
	int a = 100;
	int b = 200;
	int c = 300;
	return (a + b) * c;
}
```

javap查看字节码指令：

```text
public int calc();
    Code:
        Stack=2, Locals=4, Args_size=1 //需要深度为2的操作数栈和4个变量槽的局部变量空间
        0: bipush 100 //将100入栈
        2: istore_1 //将操作数栈顶的整型值出栈并存放到第1个局部变量槽
        3: sipush 200 //将200入栈
        6: istore_2 //将操作数栈顶的整型值出栈并存放到第2个局部变量槽
        7: sipush 300 //将300入栈
        10: istore_3 //将操作数栈顶的整型值出栈并存放到第3个局部变量槽
        11: iload_1 //将第1个局部变量槽中的整型值复制到操作数栈顶
        12: iload_2 //将第2个局部变量槽中的整型值复制到操作数栈顶
        13: iadd //将操作数栈中头两个栈顶元素出栈，做整型加法，并发结果重新入栈
        14: iload_3 //将第3个局部变量槽中的整型值复制到操作数栈顶
        15: imul // 将操作数栈中头两个栈顶元素出栈，做整型乘法，并发结果重新入栈
        16: ireturn // 方法返回指令，结束方法执行并将操作数栈顶的整型值返回给该方法的调用者
}
```

这仅仅是一种模型，虚拟机最终会对执行过程做出一系列优化来提高性能，实际情况和上面描述的概念模型差距很大，其根因是虚拟机中解析器和即时编译器都会对输入的字节码进行优化，即便是解释器也不是按照字节码指令去逐条执行的。



